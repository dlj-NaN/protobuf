# Protocol Buffers - Google's data interchange format
# Copyright 2008 Google Inc.  All rights reserved.
# https://developers.google.com/protocol-buffers/
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""Implements the generate_py_protobufs command."""

__author__ = 'dlj@google.com (David L. Jones)'

import os.path
from . import protoc_command_base

class generate_py_protobufs(protoc_command_base.ProtocCommandBase):
    """Generates Python sources for .proto files."""

    description = 'Generate Python sources for .proto files'

    def initialize_options(self):
        """Sets the defaults for the command options."""
        super().initialize_options()
        self.use_cpp_messages = False
        self.descriptor_extension_name = '_descriptors'

    def run(self):
        if self.use_cpp_messages:
            args = [
                # If the C++ messages will be used, then the Python code
                # doesn't need a copy of the descriptor.
                ('--python_out=cpp_generated_lib_linked,'
                 'descriptor_extension_name=%s:%s') % (
                     self.descriptor_extension_name,
                     self.output_dir),
                '--cpp_out=' + self.output_dir,
            ]
        else:
            args = ['--python_out=' + self.output_dir]

        self.run_protoc(args=args)

        if self.use_cpp_messages:
            # Generate a stub extension definition to load the generated C++
            # descriptors. This will be used by the 'build_ext' command.
            self._write_extension_source()

    def _write_extension_source(self):
        """Generates a stub (empty) Python extension under 'output_dir'."""
        name_path = os.path.join(
            self.output_dir,
            *self.descriptor_extension_name.split('.')) + '.c'
        self.announce('generating stub extension in ' + name_path)
        ext_fn = os.path.join(name_path)
        with open(ext_fn, 'w') as fh:
                fh.write("""\
/* -*- coding: utf-8 -*-
 * Generated by protobuf_distutils.generate_py_protobufs.
 */

#define PY_SSIZE_T_CLEAN
#include <Python.h>

static PyMethodDef methods[] = {{
    /* no methods */
    {{NULL, NULL, 0, NULL}}
}};

/*
 * This is a do-nothing module for purposes of linking generated C++ protobuf
 * descriptors.
 */
static struct PyModuleDef {0}_module = {{
    PyModuleDef_HEAD_INIT,
    /* module name */ "{0}",
    /* module doc  */ NULL,
    /* state size  */ -1,
    /* methods     */ methods
}};

PyMODINIT_FUNC PyInit_{0}(void) {{
  return PyModule_Create(&{0}_module);
}}
""".format(self.descriptor_extension_name.rsplit('.', 1)[-1]))
